/*
 * Copyright (C) 2018 Garden Technologies, Inc. <info@garden.io>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

import Joi = require("@hapi/joi")
import { ModuleVersion, moduleVersionSchema } from "../../vcs/vcs"
import { Module } from "../module"
import { ServiceStatus } from "../service"
import { moduleConfigSchema, ModuleConfig } from "../../config/module"
import { DashboardPage, dashboardPagesSchema } from "../../config/dashboard"
import { ProviderConfig, providerConfigBaseSchema } from "../../config/provider"
import { joiArray, joi } from "../../config/common"
import { deline } from "../../util/string"

export interface ConfigureProviderResult<T extends ProviderConfig = ProviderConfig> {
  config: T
  moduleConfigs?: ModuleConfig[]
}
export const configureProviderResultSchema = joi.object()
  .keys({
    config: providerConfigBaseSchema,
    moduleConfigs: joiArray(moduleConfigSchema)
      .description(deline`
        Providers may return one or more module configs, that are included with the provider. This can be used for
        modules that should always be built, or deployed as part of bootstrapping the provider.

        They become part of the project graph like other modules, but need to be referenced with the provider name
        as a prefix and a double dash, e.g. \`provider-name--module-name\`.
      `),
  })

export interface EnvironmentStatus {
  ready: boolean
  needUserInput?: boolean
  dashboardPages?: DashboardPage[]
  detail?: any
}

export const environmentStatusSchema = joi.object()
  .keys({
    ready: joi.boolean()
      .required()
      .description("Set to true if the environment is fully configured for a provider."),
    needUserInput: joi.boolean()
      .description(
        "Set to true if the environment needs user input to be initialized, " +
        "and thus needs to be initialized via `garden init`.",
      ),
    dashboardPages: dashboardPagesSchema,
    detail: joi.object()
      .meta({ extendable: true })
      .description("Use this to include additional information that is specific to the provider."),
  })
  .description("Description of an environment's status for a provider.")

export type EnvironmentStatusMap = {
  [key: string]: EnvironmentStatus,
}

export interface PrepareEnvironmentResult { }

export const prepareEnvironmentResultSchema = joi.object().keys({})

export interface CleanupEnvironmentResult { }

export const cleanupEnvironmentResultSchema = joi.object().keys({})

export interface GetSecretResult {
  value: string | null
}

export const getSecretResultSchema = joi.object()
  .keys({
    value: joi.string()
      .allow(null)
      .required()
      .description("The config value found for the specified key (as string), or null if not found."),
  })

export interface SetSecretResult { }

export const setSecretResultSchema = joi.object().keys({})

export interface DeleteSecretResult {
  found: boolean
}

export const deleteSecretResultSchema = joi.object()
  .keys({
    found: joi.boolean()
      .required()
      .description("Set to true if the key was deleted, false if it was not found."),
  })

export interface ExecInServiceResult {
  code: number
  output: string
  stdout?: string
  stderr?: string
}

export const execInServiceResultSchema = joi.object()
  .keys({
    code: joi.number()
      .required()
      .description("The exit code of the command executed in the service container."),
    output: joi.string()
      .allow("")
      .required()
      .description("The output of the executed command."),
    stdout: joi.string()
      .allow("")
      .description("The stdout output of the executed command (if available)."),
    stderr: joi.string()
      .allow("")
      .description("The stderr output of the executed command (if available)."),
  })

export interface ServiceLogEntry {
  serviceName: string
  timestamp?: Date
  msg: string
}

export const serviceLogEntrySchema = joi.object()
  .keys({
    serviceName: joi.string()
      .required()
      .description("The name of the service the log entry originated from."),
    timestamp: joi.date()
      .required()
      .description("The time when the log entry was generated by the service."),
    msg: joi.string()
      .required()
      .description("The content of the log entry."),
  })
  .description("A log entry returned by a getServiceLogs action handler.")

export interface GetServiceLogsResult { }

export const getServiceLogsResultSchema = joi.object().keys({})

export interface ModuleTypeDescription {
  docs: string
  // TODO: specify the schema using primitives and not Joi objects
  schema: Joi.ObjectSchema
  title?: string
}

export const moduleTypeDescriptionSchema = joi.object()
  .keys({
    docs: joi.string()
      .required()
      .description("Documentation for the module type, in markdown format."),
    schema: joi.object()
      .required()
      .description(
        "A valid Joi schema describing the configuration keys for the `module` " +
        "field in the module's `garden.yml`.",
      ),
    title: joi.string()
      .description(
        "Readable title for the module type. Defaults to the title-cased type name, with dashes replaced by spaces.",
      ),
  })

export type ConfigureModuleResult<T extends Module = Module> =
  ModuleConfig<
    T["spec"],
    T["serviceConfigs"][0]["spec"],
    T["testConfigs"][0]["spec"],
    T["taskConfigs"][0]["spec"]
  >

export const configureModuleResultSchema = moduleConfigSchema

export interface BuildResult {
  buildLog?: string
  fetched?: boolean
  fresh?: boolean
  version?: string
  details?: any
}
export const buildModuleResultSchema = joi.object()
  .keys({
    buildLog: joi.string()
      .allow("")
      .description("The full log from the build."),
    fetched: joi.boolean()
      .description("Set to true if the build was fetched from a remote registry."),
    fresh: joi.boolean()
      .description("Set to true if the build was performed, false if it was already built, or fetched from a registry"),
    version: joi.string()
      .description("The version that was built."),
    details: joi.object()
      .description("Additional information, specific to the provider."),
  })

export interface HotReloadServiceResult { }
export const hotReloadServiceResultSchema = joi.object()

export interface PublishResult {
  published: boolean
  message?: string
}
export const publishModuleResultSchema = joi.object()
  .keys({
    published: joi.boolean()
      .required()
      .description("Set to true if the module was published."),
    message: joi.string()
      .description("Optional result message."),
  })

export interface RunResult {
  moduleName: string
  command: string[]
  version: ModuleVersion
  success: boolean
  startedAt: Date
  completedAt: Date
  output: string
}

export const runResultSchema = joi.object()
  .keys({
    moduleName: joi.string()
      .description("The name of the module that was run."),
    command: joi.array().items(joi.string())
      .required()
      .description("The command that was run in the module."),
    version: moduleVersionSchema,
    success: joi.boolean()
      .required()
      .description("Whether the module was successfully run."),
    startedAt: joi.date()
      .required()
      .description("When the module run was started."),
    completedAt: joi.date()
      .required()
      .description("When the module run was completed."),
    output: joi.string()
      .required()
      .allow("")
      .description("The output log from the run."),
  })

export interface TestResult extends RunResult {
  testName: string
}

export const testResultSchema = runResultSchema
  .keys({
    testName: joi.string()
      .required()
      .description("The name of the test that was run."),
  })

export const getTestResultSchema = testResultSchema.allow(null)

export interface BuildStatus {
  ready: boolean
}

export const buildStatusSchema = joi.object()
  .keys({
    ready: joi.boolean()
      .required()
      .description("Whether an up-to-date build is ready for the module."),
  })

export interface RunTaskResult extends RunResult {
  moduleName: string
  taskName: string
  command: string[]
  version: ModuleVersion
  success: boolean
  startedAt: Date
  completedAt: Date
  output: string
}

export const runTaskResultSchema = joi.object()
  .keys({
    moduleName: joi.string()
      .description("The name of the module that the task belongs to."),
    taskName: joi.string()
      .description("The name of the task that was run."),
    command: joi.array().items(joi.string())
      .required()
      .description("The command that the task ran in the module."),
    version: moduleVersionSchema,
    success: joi.boolean()
      .required()
      .description("Whether the task was successfully run."),
    startedAt: joi.date()
      .required()
      .description("When the task run was started."),
    completedAt: joi.date()
      .required()
      .description("When the task run was completed."),
    output: joi.string()
      .required()
      .allow("")
      .description("The output log from the run."),
  })

export const getTaskResultSchema = runTaskResultSchema.allow(null)

export interface PluginActionOutputs {
  configureProvider: Promise<ConfigureProviderResult>

  getEnvironmentStatus: Promise<EnvironmentStatus>
  prepareEnvironment: Promise<PrepareEnvironmentResult>
  cleanupEnvironment: Promise<CleanupEnvironmentResult>

  getSecret: Promise<GetSecretResult>
  setSecret: Promise<SetSecretResult>
  deleteSecret: Promise<DeleteSecretResult>
}

export interface ServiceActionOutputs {
  getServiceStatus: Promise<ServiceStatus>
  deployService: Promise<ServiceStatus>
  hotReloadService: Promise<HotReloadServiceResult>
  deleteService: Promise<ServiceStatus>
  execInService: Promise<ExecInServiceResult>
  getServiceLogs: Promise<{}>
  runService: Promise<RunResult>
}

export interface TaskActionOutputs {
  runTask: Promise<RunTaskResult>
  getTaskResult: Promise<RunTaskResult | null>
}

export interface ModuleActionOutputs extends ServiceActionOutputs {
  describeType: Promise<ModuleTypeDescription>
  configure: Promise<ConfigureModuleResult>
  getBuildStatus: Promise<BuildStatus>
  build: Promise<BuildResult>
  publishModule: Promise<PublishResult>
  runModule: Promise<RunResult>
  testModule: Promise<TestResult>
  getTestResult: Promise<TestResult | null>
}
